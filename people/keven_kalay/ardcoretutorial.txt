This tutorial demonstrates how to communicate between openFrameworks and the Snazzy Fx Ardcore through the serial port(im sure the same code could work with the 20 objects version as well). This tutorial is taking into account you already own an Ardcore, and have Arduino software loaded on your computer as well as the openFrameworks software and a respective compiler such as Xcode.  Disclaimer 1: If there are idiosyncrasies in this tutorial they could be related to the Mac OSX operating system so if you are using PC things might not work the same for you. But should follow the same principles with minor modifications.   Disclaimer 2: I am not a computer scientist nor am I a programmer. I am a code hijacker and much of this code and comments have been appropriated from working with Christopher Baker (a professor at the School of the Art Institute of Chicago and a developer for openFrameworks).We will begin with sending potentiometer data from the Ardcore to openFrameworks through the serial port on your computer.  So, in your Arduino software make sure you have the right board and serial port selected and copy paste this code. Connect your usb port to your Ardcore and upload. If everything has gone smoothly you should be able to open your serial monitor(top right weird magnifying glass looking square) and see the four pot values changing according to your pot turns.const byte PACKET_BOUNDARY_BYTE = 255; // PACKET_BOUNDARY_BYTE:  when we read this number from the serial // device, we know we have found the boundary between two packets.  // We MUST NOT send the byte value "255" unless it is a packet boundary.  // This means that on the sender side, we must make sure our the bytes// we are sending always meet the following requirement:// 0 <= BYTE_BEING_SENT <= 254// That way we can always know that 255 means packet boundary and// not something else;const int NUM_BYTES_EXPECTED = 2;// This is the number of meaningful data bytes we expect to receive.byte buffer[NUM_BYTES_EXPECTED] = { 0, 0 };  // This is the buffer where we will store our data byte values // until we can do something with them.  We can "do something" with// Them once we know that we have a complete packet (as indiciated// by the arrival of the packet boundary marker (255).byte bufferIndex = 0;// This tells us where we are currently writing into our buffer;//----------------const int NUM_LED_PINS = NUM_BYTES_EXPECTED; // we expect one byte for each LEDconst byte LED_PINS[NUM_LED_PINS] = { 3, 4 }; //these correspond to the DO and D1 leds on the ardcorebyte ledValues[NUM_LED_PINS] = { 0, 0 };const int pot1 = A0; // these correspond the analog ins on your ardcoreconst int pot2 = A1;const int pot3 = A2;const int pot4 = A3;void setup(){    Serial.begin(9600);  for(int i = 0; i < NUM_LED_PINS; ++i)  {     pinMode(LED_PINS[i],OUTPUT);   }}void loop(){  int potValue1 = analogRead(pot1);//reading the pot values on the ardcoreint potValue2 = analogRead(pot2);int potValue3 = analogRead(pot3);int potValue4 = analogRead(pot4);  Serial.print(potValue1); // printing those valuesSerial.print(","); Serial.print(potValue2); Serial.print(","); Serial.print(potValue3);Serial.print(","); Serial.println(potValue4); // only println on the last one (to send the \r\n)  delay(50);// you can set the delay to whatever you want, keep it low for better resolution {while(Serial.available() > 0)   {    byte inByte = Serial.read();        if(inByte == 255)    {      if(bufferIndex == NUM_BYTES_EXPECTED)      {        // we know that we have found a packet boundary        // and the packet is full, so we copy the values        // to our ledValues array.                // We could write them directly into that array,         // but instead we keep the buffer and the led         // values array separate in case a byte is missing        // or a packet is malformed.  Also, in other cases,        // more complex packets might be processed         // or interpreted in a more complex way when they        // are finished.        for(int i = 0; i < NUM_LED_PINS; ++i)        {            ledValues[i] = buffer[i];        }      }       else       {        // The bufferIndex was NOT equal to the NUM_BYTES_EXPECTED        // so we did not receive a full packet.  So, we won't        // transfer the data.  This could happen because it was        // the first time data was sent, or it could happen         // because there is a bad serial connection.      }              // we reset the bufferIndex to zero because we got inByte==255      bufferIndex = 0;    }     else    {      if(bufferIndex < NUM_BYTES_EXPECTED)      {        buffer[bufferIndex] = inByte;        bufferIndex++; // move the buffer index      }      else      {        // this was some kind of error        // we had more bytes than expected before        // we received a packet boundary marker ...        // this should be investigated.        // So, we reset the buffer index to 0        bufferIndex = 0;      }    }  }  // write our values to the output.  for(int i = 0; i < NUM_LED_PINS; ++i)  {     analogWrite(LED_PINS[i],ledValues[i]);   }}}So once you’ve got your serial monitor in Arduino reading your pot values the next step is to start a new project or however you do things in oF and copy and paste this code into your testApp.h. Don’t unplug your Ardcore as serial communication requires your computer to be connected to send data back and forth. #pragma once#include "ofMain.h"class testApp : public ofBaseApp{	public:		void setup();		void update();		void draw();		void keyPressed(int key);		void keyReleased(int key);		void mouseMoved(int x, int y );		void mouseDragged(int x, int y, int button);		void mousePressed(int x, int y, int button);		void mouseReleased(int x, int y, int button);		void windowResized(int w, int h);		void dragEvent(ofDragInfo dragInfo);		void gotMessage(ofMessage msg);		    ofSerial serial;        int potValue1;    int potValue2;    int potValue3;    int potValue4;            std:: string buffer;    vector<string> vectorPotVal;    };Next step is to copy this code into your testApp.cpp. the main.cpp doesn’t need to be changed.  the only thing  you need to change is the serial port address to whatever your Ardcore is called. Then once you compile the code if all goes well and your pots are turned to zero you should see black.  A0 and A1 control red and green values of the chaotic triangle thing(also hijacked from an oF example) and A2 and A3 control the random vertical and horizontal vertices of the triangle monster.  You can also obviously sweep the triangle stuff in and out of the screen with voltage through the A2,A3 jacks.  There is also serial communication being sent from openFrameworks to the Ardcore. Once running, depending on your mouseX and mouseY position on your computer screen you will be able to trigger the digital out gates, D0 and D1.#include "testApp.h"//--------------------------------------------------------------void testApp::setup(){        ofBackground(0,0,0);    ofSetFrameRate(30);        serial.setup("/dev/tty.usbserial-A5015XXN",9600);// you will have to change this to what your serial port is called.    potValue1 = 0;    potValue2 = 0;    potValue3 = 0;    potValue4 = 0;       }//--------------------------------------------------------------void testApp::update(){        while(serial.available() > 0)    {        // Read a single byte        char myByte = serial.readByte(); // a "char" is just like a byte        //cout << "myByte is " << myByte << endl;                // If our byte is an \r that means that we don't want to add it to        // our buffer to later turn it into a number, but we instead want to        // just want to ignore it.                if(myByte == '\r') {            //cout << "myByte == '\r'!" << endl;            // nothing -- we are waiting for the \n        }        // if it is not \r then we check to see if it is an \n        else if(myByte == '\n')        {                                    // if it IS an \n then we know the buffer is full and can be            // converted into our int potValue for processing.                        vectorPotVal = ofSplitString(buffer, ",");                       potValue1 = ofToInt(vectorPotVal[0]);            potValue2 = ofToInt(vectorPotVal[1]);            potValue3 = ofToInt(vectorPotVal[2]);            potValue4 = ofToInt(vectorPotVal[3]);                                    // we then clear our buffer so that we can start adding the next            // incoming bytes that will form our next number.            vectorPotVal.clear();            buffer.clear();         }        else        {            // if it is not an \r and it is not an \n, then it must be part            // of our number.  So we use the += operator to append it to our            // string.                        // buffer += myByte is the same as saying                        // buffer = buffer + myByte                        // when we "add" two strings together remember that they aren't            // summed like numbers, but are concatenated.                        // So if buffer == "Hello World" and myByte == "!", the following            // statement buffer += myByte; would set buffer == "Hello World!"                        buffer += myByte;        }    }    // this will take the value of the mouse X position, scale it to 0-254    // and cast it into an unsigned char (a byte) so it can be sent.    // We also set clamping to TRUE which will further ensure that the range is    // always within 0-254.    unsigned char scaledMouseX = (unsigned char)ofMap(ofGetMouseX(),0,ofGetWidth(),0,254,true);// according to your mouse movement you will be able to trigger the digital outs on the ardcore        // likewise with mouse y    unsigned char scaledMouseY = (unsigned char)ofMap(ofGetMouseY(),0,ofGetHeight(),0,254,true);        // send the x byte    serial.writeByte(scaledMouseX);        // send the y byte    serial.writeByte(scaledMouseY);        // since we do not allow the range to go outside 0-254, we can send the 255    // byte as a packet boundary marker to signal the end of our packet.    serial.writeByte(255);        // REMEMBER that this is sending bytes to the arduino quite quickly    // 30 times / second (see ofSetFrameRate above).  Thus, on the Arduino    // end you will only get quick responsiveness if you do your best to avoid    // using delays in your code!  Otherwise the Arduino Serial ring buffer will fill    // (because it is getting too much data too fast) and you will start losing    // data points.      }//--------------------------------------------------------------void testApp::draw(){    // since our pot value ranges from 0-1024, we need to map it onto a range    // from 0-255 (which is what we use for colors).  We can use ofMap to do    // this.  Please see the ofMap documentation to learn about the parameters.        //int red = ofMap(potValue3,0,1024,0,255);    //int green = ofMap(potValue4, 0, 1024, 0, 255);        // we might also want to see the current value printed to the console    //cout << potValue1 << " , " << potValue2 << endl;            //ofSetHexColor(0x0cb0b6);    ofSetColor(potValue1, potValue2, 0);	ofSetPolyMode(OF_POLY_WINDING_ODD);	ofBeginShape();	for (int i = 0; i < 10; i++){		ofVertex(ofRandom(potValue3), ofRandom(potValue4));    	}    ofEndShape(true);		ofTranslate(100,0,0);		ofSetPolyMode(OF_POLY_WINDING_NONZERO);	ofBeginShape();        ofVertex(300,500);    ofVertex(380,550);    ofVertex(300,600);            }//--------------------------------------------------------------void testApp::keyPressed(int key){     }//--------------------------------------------------------------void testApp::keyReleased(int key){}//--------------------------------------------------------------void testApp::mouseMoved(int x, int y ){}//--------------------------------------------------------------void testApp::mouseDragged(int x, int y, int button){}//--------------------------------------------------------------void testApp::mousePressed(int x, int y, int button){}//--------------------------------------------------------------void testApp::mouseReleased(int x, int y, int button){}//--------------------------------------------------------------void testApp::windowResized(int w, int h){}//--------------------------------------------------------------void testApp::gotMessage(ofMessage msg){}//--------------------------------------------------------------void testApp::dragEvent(ofDragInfo dragInfo){ }This example code is just scratching the surface of what you can do with openFrameworks and the Ardcore.  I’m just presenting a sort of skeleton code to get started.  If you are a programmer you know where to go from here. But if you are a beginner easiest way to approach this code even if you don’t know what any of it means is to begin substituting those potValue variables anywhere oF needs an integer. Also remember the Ardcore is spitting out values between 0 and 1024 so you might need to ofMap some values.  There’s some commented out code in the draw loop demonstrating this.